{"version":3,"file":"PackageGraph.js","sourceRoot":"","sources":["../src/PackageGraph.ts"],"names":[],"mappings":"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","sourcesContent":["// lerna\n\nexport class PackageGraphNode {\n  readonly dependencies: Array<string> = []\n\n  constructor(readonly metadata: any) {\n  }\n}\n\nexport interface PackageMetadata {\n  name: string\n}\n\nexport class PackageGraph {\n  readonly nodes: Array<PackageGraphNode> = []\n  readonly nodesByName: any = {}\n\n  constructor(readonly packageMetadataList: Array<PackageMetadata>) {\n    for (const packageMetadata of packageMetadataList) {\n      const node = new PackageGraphNode(packageMetadata)\n      this.nodes.push(node)\n      this.nodesByName[packageMetadata.name] = node\n    }\n\n    for (const node of this.nodes) {\n      const addDeps = (dependencies: Array<any>) => {\n        const depNames = Object.keys(dependencies)\n        for (const depName of depNames) {\n          const packageNode = this.nodesByName[depName]\n          if (packageNode != null) {\n            node.dependencies.push(depName)\n          }\n        }\n      }\n\n      const dependencies = node.metadata.dependencies\n      if (dependencies != null) {\n        addDeps(dependencies)\n      }\n      const peerDependencies = node.metadata.peerDependencies\n      if (peerDependencies != null) {\n        addDeps(peerDependencies)\n      }\n    }\n  }\n\n  get(packageName: string): PackageGraphNode {\n    return this.nodesByName[packageName]\n  }\n}\n\n\nexport function topologicallyBatchPackages(packages: Array<any>) {\n  packages = packages.slice()\n  const packageGraph = new PackageGraph(packages)\n\n  // This maps package names to the number of packages that depend on them.\n  // As packages are completed their names will be removed from this object.\n  const refCounts: any = {}\n  for (const pkg of packages) {\n    for (const dep of packageGraph.get(pkg.name).dependencies) {\n      if (refCounts[dep] == null) {\n        refCounts[dep] = 0\n      }\n      refCounts[dep]++\n    }\n  }\n\n  const batches = []\n  while (packages.length > 0) {\n    // Get all packages that have no remaining dependencies within the repo that haven't yet been picked.\n    const batch = packages.filter(pkg => {\n      const node = packageGraph.get(pkg.name)\n      return node.dependencies.filter(dep => refCounts[dep]).length == 0\n    });\n\n    // If we weren't able to find a package with no remaining dependencies,\n    // then we've encountered a cycle in the dependency graph.  Run a single-package batch with the package that has the most dependents.\n    if (packages.length > 0 && !batch.length) {\n      console.warn(\"Encountered a cycle in the dependency graph. This may cause instability!\")\n      batch.push(packages.reduce((a, b) => (refCounts[a.name] || 0) > (refCounts[b.name] || 0) ? a : b))\n    }\n\n    batches.push(batch)\n\n    for (const pkg of batch) {\n      delete refCounts[pkg.name]\n      packages.splice(packages.indexOf(pkg), 1)\n    }\n  }\n\n  return batches\n}\n"]}
