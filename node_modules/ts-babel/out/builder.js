#! /usr/bin/env node
"use strict";

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

let removeOld = (() => {
    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (outDir, emittedFiles) {
        yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map((yield (0, (_fsExtraP || _load_fsExtraP()).readdir)(outDir)), function (file) {
            // ts uses / regardless of OS
            const fullPath = `${outDir}/${file}`;
            if (!file.includes(".")) {
                return removeOld(fullPath, emittedFiles);
            }
            if ((file.endsWith(".js") || file.endsWith(".js.map") || file.endsWith(".d.ts")) && !emittedFiles.has(fullPath)) {
                return (0, (_fsExtraP || _load_fsExtraP()).unlink)(fullPath);
            }
            return null;
        });
    });

    return function removeOld(_x4, _x5) {
        return _ref2.apply(this, arguments);
    };
})();

var _typescript;

function _load_typescript() {
    return _typescript = _interopRequireWildcard(require("typescript"));
}

var _babelCore;

function _load_babelCore() {
    return _babelCore = _interopRequireWildcard(require("babel-core"));
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _util;

function _load_util() {
    return _util = require("./util");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

require("v8-compile-cache");

(0, (_util || _load_util()).transpile)((() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (basePath, config, tsConfig) {
        const compilerOptions = config.options;
        if (tsConfig.declaration !== false) {
            compilerOptions.declaration = true;
        }
        compilerOptions.noEmitOnError = true;
        const program = (_typescript || _load_typescript()).createProgram(config.fileNames, compilerOptions, (_typescript || _load_typescript()).createCompilerHost(compilerOptions));
        (0, (_util || _load_util()).checkErrors)((_typescript || _load_typescript()).getPreEmitDiagnostics(program));
        const compilerOutDir = compilerOptions.outDir;
        if (compilerOutDir == null) {
            throw new Error("outDir is not specified in the compilerOptions");
        }
        yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(compilerOutDir);
        const fileToSourceMap = {};
        const promises = [];
        const emittedFiles = new Set();
        const emitResult = program.emit(undefined, function (fileName, data) {
            emittedFiles.add(fileName);
            if (fileName.endsWith(".js")) {
                const sourceMapFileName = `${fileName}.map`;
                processCompiled(data, fileToSourceMap[sourceMapFileName], fileName, sourceMapFileName, promises);
            } else if (fileName.endsWith(".js.map")) {
                fileToSourceMap[fileName] = data;
            } else {
                promises.push((0, (_fsExtraP || _load_fsExtraP()).outputFile)(fileName, data));
            }
        });
        (0, (_util || _load_util()).checkErrors)(emitResult.diagnostics);
        if (emitResult.emitSkipped) {
            throw new Error("Emit skipped");
        }
        yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all(promises);
        yield removeOld(compilerOutDir, emittedFiles);
    });

    return function (_x, _x2, _x3) {
        return _ref.apply(this, arguments);
    };
})()).catch(error => {
    console.error(error.stack || error.message || error);
    process.exit(-1);
});

function processCompiled(code, sourceMap, jsFileName, sourceMapFileName, promises) {
    const result = (_babelCore || _load_babelCore()).transform(code, {
        inputSourceMap: sourceMap == null ? null : JSON.parse(sourceMap),
        sourceMaps: true,
        filename: jsFileName
    });
    promises.push((0, (_fsExtraP || _load_fsExtraP()).outputFile)(jsFileName, result.code), (0, (_fsExtraP || _load_fsExtraP()).outputJson)(sourceMapFileName, result.map));
}
//# sourceMappingURL=builder.js.map